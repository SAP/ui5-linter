import {createRequire} from "module";
import {writeFile, readdir} from "node:fs/promises";
import path from "node:path";

interface apiJson {
	"ui5-metadata": {
		stereotype: string;
	};
	"description": string;
	"since": string;
	"visibility": string;
	"module": string;
	"name": string;
	"kind": string;
	"resource": string;
	"export": string;
	"experimental": {
		since?: string;
		text?: string;
	};
	"deprecated": {
		since?: string;
		text?: string;
	};
}

const require = createRequire(import.meta.url);

interface LibraryTypeInfo {
	pseudoModules: apiJson[];
}

type LibraryTypeInfos = Record<string, LibraryTypeInfo>;

function dotsToSlashes(str: string) {
	return str.replaceAll(".", "/");
}

async function getLibraryTypeInfos(apiJsonsRoot: string) {
	const libraryTypeInfos: LibraryTypeInfos = {};
	const apiJsonList = await readdir(apiJsonsRoot);

	apiJsonList.forEach((fileName) => {
		const libApiJson = require(path.join(apiJsonsRoot, fileName)) as {symbols: apiJson[]; library: string};
		const {library, symbols} = libApiJson;

		const libraryTypeInfo: LibraryTypeInfo = libraryTypeInfos[library] = {pseudoModules: []};

		symbols.forEach((symbol) => {
			if ((["datatype", "enum"].includes(symbol?.["ui5-metadata"]?.stereotype) ||
				symbol.kind === "enum") && symbol.resource.endsWith("/library.js")) {
				libraryTypeInfo.pseudoModules.push(symbol);
			}
		});
	});

	return libraryTypeInfos;
}

function buildJSDoc(entry: apiJson, indent = "") {
	const jsDocBuilder: string[] = [`${indent}/**`];

	if (entry.description) {
		jsDocBuilder.push(`${indent} * ${entry.description.replaceAll("\n", "\n" + indent + " * ")}`);
		jsDocBuilder.push(`${indent} *`);
	}

	if (entry.experimental) {
		let experimental = `${indent} * @experimental`;
		if (entry.experimental.since) {
			experimental += ` (since ${entry.experimental.since})`;
		}
		if (entry.experimental.text) {
			experimental += ` - ${entry.experimental.text}`;
		}
		jsDocBuilder.push(experimental);
	}

	if (entry.deprecated) {
		let deprecated = `${indent} * @deprecated`;
		if (entry.deprecated.since) {
			deprecated += ` (since ${entry.deprecated.since})`;
		}
		if (entry.deprecated.text) {
			deprecated += ` - ${entry.deprecated.text}`;
		}
		jsDocBuilder.push(deprecated);
	}

	if (entry.visibility) {
		jsDocBuilder.push(`${indent} * @${entry.visibility}`);
	}

	if (entry.since) {
		jsDocBuilder.push(`${indent} * @since ${entry.since}`);
	}
	jsDocBuilder.push(`${indent}*/`);

	return jsDocBuilder.join("\n");
}

async function createLibraryTypeDts(libraryTypeInfos: LibraryTypeInfos) {
	for (const libName of Object.keys(libraryTypeInfos)) {
		const pseudoModulesEntries = libraryTypeInfos[libName].pseudoModules;
		const stringBuilder: string[] = [
			"// This file is generated by the createTypes script.\n",
			`import "@sapui5/types/types/${libName}.d.ts";`,
		];

		if (pseudoModulesEntries.length) {
			const pseudoModulesStringBuilder: string[] = ["// This file is generated by the createTypes script.\n"];
			pseudoModulesEntries.forEach((record: apiJson) => {
				const exportName = record.export ?? record.name;
				const exportNameChunks = exportName.split(".");
				const name = exportNameChunks[0]; // Always import the first chunk and then export the whole thing
				const libraryNamespace = dotsToSlashes(libName);

				pseudoModulesStringBuilder.push(`declare module "${libraryNamespace}/${dotsToSlashes(exportName)}" {`);

				pseudoModulesStringBuilder.push(`\timport {${name}} from "${libraryNamespace}/library";`);
				pseudoModulesStringBuilder.push("");
				pseudoModulesStringBuilder.push(buildJSDoc(record, "\t"));
				pseudoModulesStringBuilder.push(`\texport default ${exportName};`);

				pseudoModulesStringBuilder.push(`}`);
				pseudoModulesStringBuilder.push("");

				return pseudoModulesStringBuilder.join("\n");
			});

			stringBuilder.push(`import "../pseudo-modules/${libName}";`);
			await writeFile(
				new URL(`../../resources/types/pseudo-modules/${libName}.d.ts`, import.meta.url),
				pseudoModulesStringBuilder.join("\n")
			);
		}

		// Creating a dedicated file for each library which serves as the entrypoint for loading all
		// relevant types of the library. This is necessary to allow lazy loading of types via
		// TypeScript's paths mapping.
		await writeFile(
			new URL(`../../resources/types/sapui5/${libName}.d.ts`, import.meta.url),
			stringBuilder.join("\n") + "\n"
		);
	}
}

export default async function createTypes(apiJsonsRoot: string) {
	const libraryTypeInfos = await getLibraryTypeInfos(apiJsonsRoot);

	await createLibraryTypeDts(libraryTypeInfos);
}
